---
title: "Introduction"
output: volker::html_report
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r include=FALSE}
knitr::opts_chunk$set(
  comment = "", 
  echo = TRUE,
  message = FALSE,
  knitr.table.format = "html"
)

```


## How to use the volkeR package?

First, load the package, set the plot theme and get some data.

```{r, warning=FALSE}

# Load the package
library(volker)

# Set the basic plot theme
theme_set(theme_vlkr())

# Load an example dataset ds from the package
ds <- volker::chatgpt

```



## How to generate tables and plots?

Decide whether your data is categorical or metric
and choose the appropriate function:  

- `tab_counts()` shows frequency tables.
- `tab_metrics()` creates tables with distribution parameters.
- `plot_counts()` generated simple and stacked bar charts.
- `plot_metrics()` visualised distributions in density plots, box plots or scatter plots.
- `effect_counts()` calculates test statistics for categorical data.
- `effect_metrics()` calculates test statistics for metric data.

The column selection determines whether to analyse single variables, item lists 
or to compare and correlate multiple variables.

**Try it out!**

### Categorical variables

```{r}
# A single variable
tab_counts(ds, use_private)
```

```{r}
# A list of variables
tab_counts(ds, c(use_private, use_work))
```

```{r}
# Variables matched by a pattern
tab_counts(ds, starts_with("use_"))
```


### Metric variables

```{r}
# One metric variable
tab_metrics(ds, sd_age)
```

```{r fig.width=6, fig.height=8}

# Multiple metric items
tab_metrics(ds, starts_with("cg_adoption_"))

```

### Cross tabulation and group comparison

Provide a grouping column in the third parameter to compare different groups.

```{r}
tab_counts(ds, adopter, sd_gender)
```

For metric variables, you can compare the mean values.

```{r}
# Compare the means of one grouping variable  (including the confidence interval)
tab_metrics(ds, sd_age, sd_gender, ci = TRUE)
```

By default, the crossing variable is treated as categorical. 
You can change this behaviour using the metric-parameter to calculate correlations:

```{r}
# Correlate two metric variables
tab_metrics(ds, sd_age, use_work, metric = TRUE, ci = TRUE)
```


Each table function has a corresponding plot function with parameters
to pimp the result. See the function help (F1 key) to learn the options.

For example, you can use the prop parameter to grow bars to 100%.
The numbers parameter prints the percentages onto the bars.

```{r}
ds |> 
  filter(sd_gender != "diverse") |> 
  plot_counts(adopter, sd_gender, prop="rows", numbers="p")
```

Further, the effect-functions implement statistical tests:

```{r}
ds |> 
  filter(sd_gender != "diverse") |> 
  effect_counts(adopter, sd_gender)
```


# Automatically generate reports

## Step by step
Reports combine plots, tables and effect calculations. Optionally, for item batteries, an index is calculated and reported.

To see an example or develop own reports, use the volker report template in RStudio:

- Create a new R Markdown document from the main menu  
- In the popup select the "From Template" option  
- Select the volker template.  
- The template contains a working example. 
  Just click knit to see the result.

Have fun with developing own reports!

Alternatively, manually add `volker::html_report` to the 
output options of your Markdown document:

```
---
title: "How to create reports?"
output: 
  volker::html_report
---
```

Then, you can generate combined outputs using the report-functions.
One advantage of the report-functions is that plots are automatically 
scaled to fit the page.

The main entry point for reports are the report-functions.
See the function help for further options (F1 key).

```{r}

ds %>% 
  filter(sd_gender != "diverse") %>% 
  report_metrics(starts_with("cg_adoption_"), sd_gender, index=TRUE, box=TRUE, ci=TRUE)

```


## Custom content
By default, a header and tabsheets are automatically created. 
You can mix in custom content.

- If you want to add content before the report outputs, 
  set the title parameter to `FALSE` and add your 
  own title.
- A good place for methodological details is a custom tabsheet 
  next to the "Plot" and the "Table" buttons. You can add a tab
  by setting the close-parameter to `FALSE` and adding a new header
  on the fifth level (5 x # followed by the tab name). 
  Close your custom new tabsheet with `#### {-}` (4 x #). 

All together, the following report output is generated by the pattern:


```{r}

#> ### Adoption types
#> 
#> ```{r echo=FALSE}
#> ds %>% 
#>   filter(sd_gender != "diverse") %>% 
#>   report_counts(adopter, sd_gender, prop="rows", title=FALSE, close=FALSE, box=TRUE, ci=TRUE)
#> ```
#>
#> ##### Method
#> Basis: Only male and female respondents.
#> 
#> #### {-}

```


### Adoption types

```{r echo=FALSE}
ds %>% 
  filter(sd_gender != "diverse") %>% 
  report_counts(adopter, sd_gender, prop="rows", title=FALSE, close=FALSE, box=TRUE, ci=TRUE)
```

##### Method
Basis: Only male and female respondents.

#### {-}


# Customizing outputs

Plot and table functions share a number of parameters that can be used to customize the outputs. Lookup the available parameters in the help of the specific function.

The theme_vlkr()-function lets you customise colors:

```{r}
theme_set(theme_vlkr(
  base_fill = c("#F0983A","#3ABEF0","#95EF39","#E35FF5","#7A9B59"),
  base_gradient = c("#FAE2C4","#F0983A")
))

```

# Custom labels: Where do they come from?

Labels used in plots and tables are stored in the comment attribute of the variable. 
You can inspect all labels using the `codebook()`-function:

```{r}
codebook(ds)
```

You can set custom or new labels with `labs_apply()` by providing a tibble 
with item names in the first column and item labels in the second column.

```{r}
newlabels <- tribble(
  ~item_name, ~item_label,
  "cg_adoption_advantage_01", "Allgemeine Vorteile",
  "cg_adoption_advantage_02", "Finanzielle Vorteile",
  "cg_adoption_advantage_03", "Vorteile bei der Arbeit",
  "cg_adoption_advantage_04", "Macht mehr SpaÃŸ"
)

ds %>%
  labs_apply(newlabels) %>%
  tab_metrics_items(starts_with("cg_adoption_advantage_"))


```

Alternatively, save the result of `codebook(ds)` to an Excel file,
change the labels and then call `labs_apply()` with your new codebook.



# Index calculation for item batteries

You can calculate mean indexes from a bunch of items using `idx_add()`. 
A new column is created with the average value of all selected columns
for each case. 

Reliability and number of items are calculated with `psych::alpha()`
and stored as column attribute named "psych.alpha". The reliability values 
are printed by `tab_metrics()`.

**Add a single index**
```{r}
ds %>%
  idx_add(starts_with("cg_adoption_")) %>%
  tab_metrics(idx_cg_adoption)
```

**Compare the index values by group**
```{r}
ds %>%
  idx_add(starts_with("cg_adoption_")) %>%
  tab_metrics(idx_cg_adoption, adopter)
```

**Add multiple indizes and summarize them**
```{r}
ds %>%
  idx_add(starts_with("cg_adoption_")) %>%
  idx_add(starts_with("cg_adoption_advantage")) %>%
  idx_add(starts_with("cg_adoption_fearofuse")) %>%
  idx_add(starts_with("cg_adoption_social")) %>%
  tab_metrics(starts_with("idx_cg_adoption"))
```


# What's behind the scenes?

The volker-package is based on standard methods for data handling and visualisation. 
You can produce all outputs with a handful of functions. The package just makes your
code dry - don't repeat yourself - and wraps often used snippets into a simple interface.

Basically, all table values are calculated two tidyverse functions:

- count() is used to produce counts  
- skim() is used to produce metrics  

To shape the data frames, two essential functions come into play:  

- group_by() is used to calculate grouped outputs
- pivot_longer() brings multiple items into a format where the item name becomes a grouping variable.  

Plots are generated by `ggplot()`.

The package provides print- and knit-functions that pimp console and markdown output. 
To make this work, the cleaned data, produced plots, tables and markdown snippets 
gain new classes (`vlkr_df`, `vlkr_plt`, `vlkr_tbl`, `vlkr_list`, `vlkr_rprt`).

---
title: "Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r include=FALSE}
knitr::opts_chunk$set(
  comment = "", 
  echo = TRUE
)

# Load the packages
library(tidyverse)
library(volker)

# Set the basic plot theme
theme_set(theme_bw())
```


```{r include=FALSE}

# Load example data from the package
data <- volker::chatgpt

# The prepare() function makes typical survey output,
# for example from Sosci Survey, ready for analysis.
# Particularly, negative -9 values are recoded to NA.
data <- volker::prepare(data)

# Add label to sd_alter
data <- set_item_labels(
  data, 
  tibble("sd_alter", "Alter")
)

```

## 1. One variable


### Frequency table for one categorical variable: Gender
```{r}
tab_counts_one(data, sd_geschlecht)
```

### Distribution table for one metric variable: Age
```{r}
tab_metrics_one(data, sd_alter)
```

## 2. Multiple items

### Frequency table for multiple categorical variables: Adoption factors
```{r}
tab_counts_items(data, starts_with("cg_adoption_"))
```

### Distribution table for multiple metric items: Adoption factors
```{r}
tab_metrics_items(data, starts_with("cg_adoption_"))
plot_metrics_items(data, starts_with("cg_adoption_"))

```

## 3. Two variables (one being categorical)

### Cross table of categorical variables: Innovator type by gender

```{r}
tab_counts_one_grouped(data, in_adoption, sd_geschlecht)
```

### Group comparison of a metric variable: Age by gender

```{r}
tab_metrics_one_grouped(data, sd_alter, sd_geschlecht)
```

## 4. Multiple metric variables

### Compare means of multiple items: Adoption factors by gender
```{r}
tab_metrics_items_grouped(data, starts_with("cg_adoption_"), sd_geschlecht)
```

### Correlation of items: Adoption factors
```{r}
tab_metrics_items_cor(data, starts_with("cg_adoption_adv"))

tab_metrics_items_cor(data, starts_with("cg_adoption_adv"), starts_with("cg_nutzen"))
```

# Automatically generate reports

Reports combine plots and tables. Optionally, for item batteries, an index is calculated and reported.

**TODO: the template is not included yet**
To see an example or develop own reports, use the volker report template in RStudio:
- Create a new R Markdown document from the main menu
- In the popup select the "From Template" option
- Select the volker template.
- The template contains a working example. Click knit to see the result.
Have fun with developing own reports!

The main entry point for reports is the report()-function.
It takes your dataset as first parameter.
Given a list of column prefixes in the second parameter,
the appropriate table and plot types are guessed

- If the prefix matches a single column, tab_counts_one() and plot_counts_one() will be used.
  If the prefix matches multiple columns, tab_counts_items() and plot_counts_items() will be used.
- If the data contains metric values, the corresponding metric functions are used.  

In the third parameter, you can provide a grouping column to generate the corresponding grouped tables or plots.
See the function help for further options.

```{r}
report(
  data,
  c(
    "cg_adoption_advantage_",
    "sd_geschlecht"
  )
)
```

# Customizing outputs

Plot and table functions share a number of parameters that can be used to customize the outputs. Lookup the available parameters in the help of the specific function:

- labels: Labels are extracted from the column attributes, if present. Set to FALSE to output bare column names and values.  
- title: All plots usually get a title derived from the column attributes or column names. Set to FALSE to suppress the title or provide a title of your choice as a character value.  
- percent: Frequency tables show percentages by default. Set to FALSE to get raw proportions - easier to postprocess in further calculations.
- digits: Tables containing means and standard deviations by default round values to one digit. Increase the number to show more digits.
- numbers: Bar plots give quick impressions, tables provide exact numbers. In bar charts you can combine both and print the frequencies onto the bars. Set the numbers parameter to "n", "p" or c("n","p"). To prevent cluttering and overlaps, numbers are only plotted on bars larger than 5%.
- values: The more variables you desire, the denser the output must be. Some tables try to serve you insights at the maximum and show two values in one cell, for example the absolute counts (n) and the percentages (p), or the mean (m) and the standard deviation (sd). Control your desire with the values-parameter.
- prop: Calculating percentages in a cross tab requires careful selection of the base. You can choose between total, row or column percentages. For stacked bar charts, displaying row percentages instead of total percentages gives a direct visual comparison of groups.
- negative: In surveys, negative values such as -9 or -2 are often used to mark missing values or residual answers ("I don't know"). Therefore, all metric tables and plots remove negative values before calculation distribution parameters such as the mean. Set negative to TRUE for including those values. By the way: The handy prepare()-function can be used to recode all -9 to NA in a dataset.
- missings: The number of missing values is an important indicator for data quality. In reports, the missings usually are ommited and so do the package functions by default. For data set statics - for example when you monitor an ongoing survey or prepare a data set - you should set the missings-parameter to TRUE if the function supports it.
- ordered: Sometimes categories have an order, from low to high or from few to many. It helps visual inspections to plot ordered values with shaded colors instead of arbitrary colors. For frequency plots, you can inform the method about the desired order. By default the functions try to automatically detect a sensitive order.
- limits: Do you know how to create misleading graphs? It happens when you truncate the minimum or maximum value in a scale. The scale limits are automatically guessed by the package functions (work in progress). Use the limits-parameter to manually fix any misleading graphs.

# Set custom item labels

Item labels are stored in the comment attribute of an item variable. 
When printing item tables, the labels are used. You can set custom or 
new labels by providing a tibble with item names in the first column
and item labels in the second.

```{r}
newlabels <- tribble(
  ~item_name, ~item_label,
  "cg_adoption_advantage_01", "Allgemeine Vorteile",
  "cg_adoption_advantage_02", "Finanzielle Vorteile",
  "cg_adoption_advantage_03", "Vorteile bei der Arbeit",
  "cg_adoption_advantage_04", "Macht mehr SpaÃŸ"
)

data %>%
  set_item_labels(newlabels) %>%
  tab_metrics_items(starts_with("cg_adoption_advantage_"))
```

# What's behind the scenes?

The volker-package is based on standard methods for data handling and visualisation. 
You can produce all outputs with a handful of functions. The package just makes your
code dry - don't repeat yourself - and wraps often used snippets into a simple interface.

Basically, all table values are calculated two Tidyverse functions:
- count() is used to produce counts
- skim() is used to produce metrics

To shape the data frames, two essential functions come into play:
- group_by() is used to calculate grouped outputs
- pivot_longer() brings multiple items into a format where the item name becomes a grouping variable.

Plots are generated by ggplot()

The package provides print- and knit-functions that pimp console and markdown output. 
To make this work, the produced plots, tables and markdown snippets gain new classes (vlkr_plt, vlkr_tb, vlkr_rprt).

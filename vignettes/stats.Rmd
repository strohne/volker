---
title: "Introduction"
output: volker::html_report
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r include=FALSE}
knitr::opts_chunk$set(
  echo = F,
  knitr.table.format = "html"
)

library(tidyverse)
library(volker)
```

```{r}

# Load data 
ds <- volker::chatgpt

# Metrics for innovator type items 

tab_metrics_one_grouped(ds, sd_age, adopter)

# Stats table 
# TODO: Fix labels and add another table that shows overall model stats (e.g.R^2)
stats_metrics_one_grouped(ds, sd_age, adopter)


# Plot metrics without stats 
# TODO: fix scale 

plot_metrics_one_grouped(ds, sd_age, adopter)

# Plot metrics with stats 

plot_metrics_one_grouped(ds, sd_age, adopter, stats=T)
plot_metrics_one_grouped(ds, cg_adoption_social_03, adopter, stats=T)

```


```{r}

# function using ggpubr for confidence intervals 

temp <- function(data, col, col_group, limits = NULL, negative = FALSE, stats = FALSE, title = TRUE, labels = TRUE, clean = TRUE, ...) {

  # 1. Check parameters
  check_is_dataframe(data)
  check_has_column(data, {{ col }})
  check_has_column(data, {{ col_group }})

  # 2. Clean
  if (clean) {
    data <- data_clean(data)
  }
  
  # Remove negative values
  # TODO: warn if any negative values were recoded
  if (!negative) {
  neg_values <- data %>%  
    dplyr::summarise(neg = sum({{ col }} < 0))
  
  if (neg_values$neg > 0) {
    message("Negative values were recoded to NA.")
  }
  
  data <- data |>
    labs_store() |>
    dplyr::mutate(dplyr::across({{ col }}, ~ ifelse(. < 0, NA, .))) |>
    labs_restore()
}

  # Drop missings and print message 
  
  missings <- data %>%  
    dplyr::summarise(n = sum(is.na({{ col }})))
  
  message(paste0("A total of ", missings$n, " missing values have been removed."))
  
  data <- tidyr::drop_na(data, {{ col }}, {{ col_group }})

  if (stats) {
    
  pl <- data %>%
    ggplot2::ggplot(ggplot2::aes(y={{ col }}, {{ col_group}})) +
    ggplot2::stat_summary(geom = "point", fun = mean, colour = VLKR_POINTCOLOR) + 
    ggplot2::stat_summary(geom = "errorbar", fun.data = ggpubr::mean_ci)
  } else {

  pl <- data %>%
    ggplot2::ggplot(ggplot2::aes(y={{ col_group }}, {{ col }})) +
    ggplot2::geom_boxplot(fill="transparent", color="darkgray") +
    ggplot2::stat_summary(fun = mean, geom="point",colour=VLKR_POINTCOLOR, size=4, shape=18) 
  }
  
  # Set the scale
  # if (is.null(limits)) {
  #   limits <- get_limits(data, {{ col }})
  # }

  scale <- c()
  if (labels) {
    scale <- attr(dplyr::pull(data, {{ col }}), "scale")
    if (is.null(scale)) {
      scale <- data %>%
        codebook({{ col }}) %>%
        dplyr::distinct(dplyr::across(tidyselect::all_of(c("value_name", "value_label"))))
    }
    scale <- prepare_scale(scale)
  }
  if (length(scale) > 0) {
    pl <- pl +
      ggplot2::scale_y_continuous(labels = ~ label_scale(., scale) )
  } else {
    pl <- pl +
      ggplot2::scale_y_continuous()
  }

  # Add scales, labels and theming
  pl <- pl +
    ggplot2::scale_x_discrete(labels = scales::label_wrap(40), limits = rev) +


    # TODO: set limits
    #coord_flip(ylim = limits) +
    ggplot2::theme(
      axis.title.x = ggplot2::element_blank(),
      axis.title.y = ggplot2::element_blank(),
      axis.text.y = ggplot2::element_text(size = 11),
      legend.title = ggplot2::element_blank(),
      plot.caption = ggplot2::element_text(hjust = 0),
      plot.title.position = "plot",
      plot.caption.position = "plot"
    )

#
#   if (!is.null(numbers)) {
#     pl <- pl +
#       geom_text(
#         # aes(label=paste0("âŒ€", round(m,1))),
#         aes(label = round(m, 1)),
#         #position = position_stack(vjust = 0.5),
#         hjust = -1,
#         vjust=0.5,
#         size = 3,
#         color = "black"
#       )
#   }

  # Add title
  if (title == TRUE) {
    title <- get_title(data, {{ col }})
  }
  else if (title == FALSE) {
    title <- NULL
  }

  if (!is.null(title)) {
    pl <- pl + ggplot2::ggtitle(label = title)
  }

  # Add base
  # TODO: Report missing values, output range
  base_n <- nrow(data)
  
  categorical_n <- 
    dplyr::group_by(data, {{ col_group }}) %>% 
    dplyr::count() 
  
  pl <- pl + ggplot2::labs(caption = paste0("n=", base_n, ", ",
                          paste(categorical_n[[1]], "=", 
                          categorical_n$n, collapse = ", "),
                          ", Missings = ", missings$n)
  )
  
  # Maximum label length
  maxlab  <- data %>%
    dplyr::pull({{col_group}}) %>%
    stringr::str_length() %>%
    max(na.rm= TRUE)

   # Pass row number and label length to the knit_plot() function
  .to_vlkr_plot(pl, maxlab=maxlab)
}

temp(ds, cg_adoption_social_03, adopter, stats = T, clean = F)

```


```{r}
# function using own calculation 

temp2 <- function(data, col, col_group, limits = NULL, negative = FALSE, stats = FALSE, title = TRUE, labels = TRUE, clean = TRUE, ...) {

  # 1. Check parameters
  check_is_dataframe(data)
  check_has_column(data, {{ col }})
  check_has_column(data, {{ col_group }})

  # 2. Clean
  if (clean) {
    data <- data_clean(data)
  }

  # Remove negative values
  # TODO: warn if any negative values were recoded
  if (!negative) {
    data <- data |>
      labs_store() |>
      dplyr::mutate(dplyr::across({{ col }}, ~ ifelse(. < 0, NA, .))) |>
      labs_restore()
  }

  # Drop missings
  # TODO: Report missings
  
  data <- tidyr::drop_na(data, {{ col }}, {{ col_group }}, warn = T)
  

  if (stats) {
    
  data <- data %>%  
    group_by({{ col_group }}) %>%
  summarise( 
    n=n(),
    mean=mean({{ col }}),
    sd=sd({{ col }})
  ) %>%
  mutate(se=sd/sqrt(n))  %>%
  mutate(ic=se * qt((1-0.05)/2 + .5, n-1))
    
  pl <- data %>%
    ggplot2::ggplot(ggplot2::aes(y={{ col_group }}, x=mean)) +
    ggplot2::geom_point(colour=VLKR_POINTCOLOR) +
    ggplot2::geom_errorbar(aes(xmin=mean-ic, xmax=mean+ic))
  
  } else {

  pl <- data %>%
    ggplot2::ggplot(ggplot2::aes(y={{ col_group }}, {{ col }})) +
    ggplot2::geom_boxplot(fill="transparent", color="darkgray") +
    ggplot2::stat_summary(fun = mean, geom="point",colour=VLKR_POINTCOLOR, size=4, shape=18)
  }
  
  .to_vlkr_plot(pl)
}

temp2(ds, sd_age, adopter, stats = T)

```


```{r}

# function using ggpubr with stats_compare_means 

temp3 <- function(data, col, col_group, limits = NULL, negative = FALSE, stats = FALSE, title = TRUE, labels = TRUE, clean = TRUE, ...) {

  # 1. Check parameters
  check_is_dataframe(data)
  check_has_column(data, {{ col }})
  check_has_column(data, {{ col_group }})

  # 2. Clean
  if (clean) {
    data <- data_clean(data)
  }

  # Remove negative values
  # TODO: warn if any negative values were recoded
  if (!negative) {
    data <- data |>
      labs_store() |>
      dplyr::mutate(dplyr::across({{ col }}, ~ ifelse(. < 0, NA, .))) |>
      labs_restore()
  }

  # Drop missings
  # TODO: Report missings
  data <- tidyr::drop_na(data, {{ col }}, {{ col_group }})

  if (stats) {
    
    pl <- data %>%
    ggplot2::ggplot(ggplot2::aes(y={{ col }}, {{ col_group}})) +
  ggplot2::stat_summary(geom = "point", fun = mean, colour = VLKR_POINTCOLOR) + 
    ggplot2::stat_summary(geom = "errorbar", fun.data = ggpubr::mean_ci) + ggpubr::stat_compare_means()
  
  } else {

  pl <- data %>%
    ggplot2::ggplot(ggplot2::aes(y={{ col_group }}, {{ col }})) +
    ggplot2::geom_boxplot(fill="transparent", color="darkgray") +
    ggplot2::stat_summary(fun = mean, geom="point",colour=VLKR_POINTCOLOR, size=4, shape=18)
  }
  
  .to_vlkr_plot(pl)
}

# ds <- ds %>% 
#  filter(adopter != "I only use new offers when I have no other choice", 
#        sd_gender != "diverse") 

temp3(ds, sd_age,adopter,stats = T)

```

